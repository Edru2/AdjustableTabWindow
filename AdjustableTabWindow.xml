<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>AdjustableTabWindow</name>
			<packageName></packageName>
			<script>-- Adjustable TabWindow
-- TabWindow code by Mudlet Wiki
-- other functions
-- by Edru 16th May 2020 

Adjustable = Adjustable or {}
Adjustable.TabWindow = Adjustable.TabWindow or Geyser.Container:new({name = "AdjustableTabWindowClass"})
local tab_pos = nil

function Adjustable.TabWindow:createBaseContainers()
    self.tabBar = self.tabBar or Geyser.Label:new({        
        name = self.name.."tabBar",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    self.tabBar:setStyleSheet(self.tabBarStyle)
    
    self.header = self.header or Geyser.HBox:new({
        name = self.name.."header",
        x = 0, y = 0,
        width = "100%",
        height = "100%",
    },self.tabBar)
    
    self.overlay = self.overlay or Geyser.Label:new({
        name = self.name.."overlay",
        x = 0, y = 0,
        width = "100%",
        height = self.tabBarHeight,
    },self)
    
    self.overlay:setStyleSheet(self.overlayStyle)
    self.overlay:setMoveCallback(function(event) self:onOverlayMove(event) end)
    self.overlay:setOnLeave(function(event) self:onOverlayLeave(event) end)
    self.overlay:setClickCallback(function(event) self:onOverlayClick(event) end)
    self.overlay:hide()
    
    self.footer = self.footer or Geyser.Label:new({
        name = self.name.."footer",
        x = 0, y = self.tabBarHeight,
        width = "100%",
        height = "-"..self.tabBarHeight,
    },self)
    
    self.footer:setStyleSheet(self.footerStyle)
end

-- function to create new tabs in tabs table or to rewrite/readjust them
function Adjustable.TabWindow:createTabs()
    for k,v in ipairs(self.tabs) do
        self[v] = self[v] or Geyser.Label:new({
            name = v,
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self.footer)
        
        self[v]:setStyleSheet(self.containerStyle)
        self[v].tabText = self[v].tabText or "&lt;center&gt;"..v
        
        self[v.."tab"] = self[v.."tab"] or Adjustable.Container:new({
            name = v.."tab",
            tabname = v,
            noLimit = true,
            titleText = self[v].tabText,
            padding = 0,
            locked = true,
            autoSave = false,
            autoLoad = false,
            raiseOnClick = false,
            adjLabelstyle = self.inactiveTabStyle,
            titleTxtColor = self.tabTxtColor
        }, self.header)
        
        self[v.."tab"]:newLockStyle("tab", 
        function(self)         
            self.Inside:resize("-"..self.padding,"-"..self.padding)
            self.Inside:move(self.padding, self.padding*2) 
        end)
        
        self[v.."tab"].lockStyle = "tab"
        
        self[v.."tab"].unlockContainer = function()
            Adjustable.Container.unlockContainer(self[v.."tab"])
            self[v.."tab"].adjLabel:echo(self[v].tabText)
        end
        
        Adjustable.TabWindow.allTabs[v] = self
        
        self[v.."tab"].reposition = self.reposition
        table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, v.."tab"))
        Adjustable.Container.all[v.."tab"] = nil
        self[v.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[v.."tab"].titleTxtColor = self.tabTxtColor
        self[v.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        
        self[v.."tab"].adjLabel:echo(self[v].tabText)
        
        self[v.."tab"].adjLabel:setClickCallback(function(event) self:onClick(v, event) end)
        self[v.."tab"].adjLabel:setReleaseCallback(function(event) self:onRelease(v, event) end)
        self[v.."tab"].adjLabel:setMoveCallback(function(event) self:onMove(v, event) end)
        self[v.."tab"].adjLabel:setDoubleClickCallback(function(event) self:onDoubleClick(v, event) end)
        self[v.."tab"].minimizeLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        self[v.."tab"].minimizeLabel:echo("&lt;center&gt;ðŸ——&lt;/center&gt;")
        self[v.."tab"].minLabel:setClickCallback(function() self:onMinimizeClick(v) end)
        
        
        self[v.."center"] = self[v.."center"] or Geyser.Label:new({
            name = v.."center",
            x = 0, y = 0,
            width = "100%",
            height = "100%",
        },self[v])
        
        self[v.."center"]:setStyleSheet(self.centerStyle)
        self[v]:hide()
    end
end

-- finds the right position to drop the tab into
function Adjustable.TabWindow:findPosition(tab)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local x, w = myWindow.get_x(), myWindow.get_width()
    local total = w/#myWindow.tabs
    local tab_x = tab.get_x() - x
    local position = (tab_x/total) + 1
    position = math.floor(position + 0.5)
    if position &lt; 1 then
        position = 1
    end
    if position &gt; #myWindow.tabs then
        position = #myWindow.tabs + 1
    end
    return position
end

-- checks if 2 elements collide
local function checkCollision(x1,y1,w1,h1, x2,y2,w2,h2)
    if  x1 &lt; x2+w2 and
    x2 &lt; x1+w1 and
    y1 &lt; y2+h2 and
    y2 &lt; y1+h1 then
        return true
    end
end

-- checks if your tab collides with one of the tabwindows
function Adjustable.TabWindow:checkMultiCollision(tab)
    local x1, y1, w1, h1 = tab:get_x(), tab:get_y(), tab:get_width(), tab:get_height()
    for k,v in pairs(Adjustable.TabWindow.all) do
        local x2, y2, w2, h2 = v:get_x(), v:get_y(), v:get_width(), v:get_height()
        
        if checkCollision(x1,y1,w1,h1, x2,y2,w2,h2) and v.windowname == self.windowname then
            return true, v
        end
    end  
end

-- onMove function
-- contains all the functionality to move the tab (collision check, make space ...)
function Adjustable.TabWindow:onMove(tab, event)
    self[tab.."tab"]:onMove(self[tab.."tab"].adjLabel, event)
    self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    if self[tab].floating then
        return
    end
    if Adjustable.TabWindow.clicked then  
        local result, value = self:checkMultiCollision(self[tab.."tab"])
        if Adjustable.TabWindow.currentWindow and Adjustable.TabWindow.currentWindow ~= value then
            -- reset the tab space
            self:makeSpace(Adjustable.TabWindow.currentWindow, nil, true)
        end
        if result then
            Adjustable.TabWindow.currentWindow = value
            tab_pos = value:findPosition(self[tab.."tab"])
            self:makeSpace(value, tab_pos)
        else
            if Adjustable.TabWindow.currentWindow then
                Adjustable.TabWindow.currentWindow = nil
            end
        end
    end
end

-- mouse movement on the overlay label
function Adjustable.TabWindow:onOverlayMove(event)  
    Adjustable.TabWindow.currentWindow = self
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        -- need to feed values to findPosition
        local fakeTab = {}
        fakeTab.get_x = function() return event.x + self.header.get_x() end    
        tab_pos = self:findPosition(fakeTab)
        self:makeSpace(self, tab_pos)
    end
end

-- reset tabspace after mouse leaves overlay label and resets the currentWindow
function Adjustable.TabWindow:onOverlayLeave(event)
    Adjustable.TabWindow.currentWindow = nil
    if not(Adjustable.TabWindow.doubleClick) then
        return
    end
    local tab = Adjustable.TabWindow.clickedTab.name
    if Adjustable.TabWindow.clickedTab ~= self.header.windowList[tab] then
        self:makeSpace(nil, nil, true)
    end
end

-- reset the Overlay label to be hidden
local function resetOverlay(v)
    if Adjustable.TabWindow.overlayTimer then
        killTimer(Adjustable.TabWindow.overlayTimer)
        Adjustable.TabWindow.overlayTimer = nil
    end
    for k,v in pairs(Adjustable.TabWindow.all) do 
        v.overlay:setStyleSheet("background-color: rgba(0,0,0,0%);") 
        v.overlay:hide()
    end  
    if Adjustable.TabWindow.currentWindow then
        Adjustable.TabWindow.currentWindow:makeSpace(nil, nil, true)
    end
    Adjustable.TabWindow.doubleClick = nil
    tab_pos = nil
end

-- handles on overlay click event
function Adjustable.TabWindow:onOverlayClick(event) 
    Adjustable.TabWindow.doubleClick = nil
    local tab = Adjustable.TabWindow.clickedTab
    local container = Adjustable.TabWindow.clickedTab.container.container.container or self
    tab.adjLabel:setStyleSheet(container.activeTabStyle)
    if container[tab.tabname].floating then
        container:restoreTab(tab.tabname, self)
        self:addTab(tab.tabname, tab_pos)
    else
        container:onRelease(tab.tabname, event)
    end
    resetOverlay(self)
end

-- if clicked on the minimize label the tab will be 
-- restored to be in a tabwindow again
function Adjustable.TabWindow:onMinimizeClick(tab)  
    local result, value = self:checkMultiCollision(self[tab.."tab"])
    self:restoreTab(tab, value)
end

-- activates the tab tab (doesn't deactivate the previous tab)
-- @see Adjustable.TabWindow:deactivateTab()
function Adjustable.TabWindow:activateTab(tab)
    self.current = tab
  if self.current then
    self[tab.."tab"].adjLabelstyle = self.activeTabStyle
    self[tab.."tab"].adjLabel:setStyleSheet(self.activeTabStyle)
    self[self.current]:show()
    end
end

-- deactivates and hides the current active tab
function Adjustable.TabWindow:deactivateTab()
    if self.current and self[self.current] then  
        self[self.current.."tab"].adjLabelstyle = self.inactiveTabStyle
        self[self.current.."tab"].adjLabel:setStyleSheet(self.inactiveTabStyle)
        self[self.current]:hide()
    end
end

-- handles click event on tab
function Adjustable.TabWindow:onClick(tab, event)
    Adjustable.TabWindow.currentWindow = self
    if event.button == "LeftButton" and not self[tab].floating then
        self[tab.."tab"]:resize(self[tab.."tab"].get_width(),self[tab.."tab"].get_height())
        self[tab.."tab"].container = Geyser
        -- set minimized to true to prevent resizing
        self[tab.."tab"].minimized = true
        self[tab.."tab"]:unlockContainer()
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:raise(false)
        self[tab.."tab"].exitLabel:hide()
        self[tab.."tab"].minimizeLabel:hide()
        Adjustable.TabWindow.clicked = true
        Adjustable.TabWindow.clickedTab = self[tab.."tab"]
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
    end
    
    if self[tab].floating then
        self[tab.."tab"]:onClick(self[tab.."tab"].adjLabel, event)
    end
    if not self[tab].floating then
        self:deactivateTab()
        self:activateTab(tab)
    end
end

-- handles double click event on getAreaTable
-- activates the tab overlay
function Adjustable.TabWindow:onDoubleClick(tab, event)
    -- Prevent windows to float
    self[tab.."tab"].container = self.header
    Adjustable.TabWindow.currentWindow = self
    Adjustable.TabWindow.doubleClick = true
    Adjustable.TabWindow.clickedTab = self[tab.."tab"]
    self[tab.."tab"].adjLabel:setStyleSheet(self.chosenTabStyle)
    for k,v in pairs(Adjustable.TabWindow.all) do
        v.overlay:show()
        v.overlay:raise()
        v.overlay:setStyleSheet(v.overlayStyle)
    end
    Adjustable.TabWindow.overlayTimer = Adjustable.TabWindow.overlayTimer or tempTimer(15, function() resetOverlay(v) end )
end

-- transforms the tab to a window
function Adjustable.TabWindow:transformTabContainer(tab)
    local myWindow = Adjustable.TabWindow.allTabs[tab] or self
    local container = self[tab.."tab"]
    if container.windowname == "main" then
        Geyser:add(container)
    else
        Geyser.windowList[container.windowname.."Container"].windowList[container.windowname]:add(container)
    end
    container:unlockContainer()
    container:resize(self.get_width(), self.get_height())
    container:add(self[tab])
    myWindow:removeTab(tab)
    myWindow:createTabs()
    container:setPadding(self.tabPadding)
    container:show()
    container:raiseAll()
    myWindow[tab].floating = true
    container.raiseOnClick = true
    container.adjLabel:echo(self[tab].tabText)
    container.minimized = false
    container:setPercent(true, true)
    myWindow:activateTab(tab)
    if #myWindow.tabs &gt; 0 then
        myWindow:activateTab(myWindow.tabs[1])
    else 
        myWindow.current = nil
    end
end

--restores the window to be a tab again
function Adjustable.TabWindow:restoreTab(tab, myWindow)
    myWindow = myWindow or self
    local container = self[tab.."tab"]
    container.container:remove(container)
    container:remove(self[tab])
    container:setPadding(0)
    container:lockContainer()
    container.adjLabel:echo(self[tab].tabText)
    self:changeTabContainer(tab, myWindow)
    self[tab].floating = false
    container.raiseOnClick = false
end

-- function to make a gap where the tab can be dropped in
function Adjustable.TabWindow:makeSpace(myWindow, position, resetSpace)
    myWindow = myWindow or self
    position = position or #myWindow.header.windows
    if position &lt; 1 then position = 1 end
    local current_Tab = Adjustable.TabWindow.clickedTab or {}
    local total_count = #myWindow.header.windows + 1
    -- close the space if resetSpace is true
    if resetSpace then
        position = -1
        total_count = total_count -1
    end
    
    if myWindow == self and current_Tab.name and not(Adjustable.TabWindow.doubleClick) then
        total_count = total_count -1
    end
    local new_width = myWindow.get_width() / total_count
    local new_x = 0
    local counter = 1
    for k,v in ipairs(myWindow.header.windows) do
        if v ~= current_Tab.name then
            if counter == position then
                new_x = new_x + new_width
            end
            myWindow.header.windowList[v]:resize(new_width)
            myWindow.header.windowList[v]:move(new_x)   
            new_x = new_x + new_width
            counter = counter + 1  
        end
    end
end

-- function to change the parent window of the tab 
function Adjustable.TabWindow:changeTabContainer(tab, myWindow, position)
    myWindow[tab] = self[tab]
    myWindow[tab.."tab"] = self[tab.."tab"]
    myWindow[tab.."center"] = self[tab.."center"]
    self[tab.."tab"].container = not(self[tab].floating) and self.header or Geyser 
    self[tab]:changeContainer(myWindow.footer)
    self[tab.."tab"]:changeContainer(myWindow.header)
    if not (self[tab].floating) then
        self:removeTab(tab)
        self:createTabs()
    end
    myWindow:createTabs()
    myWindow[tab.."tab"]:show()
    myWindow:addTab(tab, position)
    if self.current then
        self[self.current]:show()
    end
    if #self.tabs &gt; 0 then
        if not (self[tab].floating) then
            self:activateTab(self.tabs[1])
        end
    else 
        self.current = nil
    end
    myWindow:activateTab(tab)
end

-- handles the release event
function Adjustable.TabWindow:onRelease(tab, event, position)
    local myWindow = Adjustable.TabWindow.currentWindow or self
    local floating = self[tab].floating
    if event.button == "LeftButton" and Adjustable.TabWindow.currentWindow and not floating then
        self[tab.."tab"]:lockContainer()
        self[tab.."tab"].container = self.header
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
        self[tab.."tab"].adjLabel:echo(self[tab].tabText)
        tab_pos = tab_pos or myWindow:findPosition(self[tab.."tab"])
        if myWindow ~= self then
            self:changeTabContainer(tab, myWindow)
        end  
        myWindow:addTab(tab, tab_pos)
        myWindow:raiseAll()
    end
    
    if event.button == "LeftButton" and not(Adjustable.TabWindow.currentWindow) and not floating then
        self:transformTabContainer(tab)
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    if floating then
        self[tab.."tab"]:onRelease(self[tab.."tab"].adjLabel, event)
    end
    
    Adjustable.TabWindow.clicked = false
    Adjustable.TabWindow.currentWindow = nil
    if not (Adjustable.TabWindow.doubleClick) then
        Adjustable.TabWindow.clickedTab = nil
    end
    tab_pos = nil
end

-- change the text a tab displays
function Adjustable.TabWindow:setTabText(which, text)
    assert(type(which) == "string" or type(which) == "number", "setTabText: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    assert(type(text) == "string", "setTabText: bad argument #2 type (tab text as string expected, got "..type(text).."!)")
    text = "&lt;center&gt;"..text
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which]].tabText = text
        self[self.tabs[which].."tab"].adjLabel:echo(text)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index]].tabText = text
        self[self.tabs[index].."tab"].adjLabel:echo(text)
        return true
    end
    return nil, "setTabText: Couldn't find tab to set a new text"
end

-- removes a tab (this won't be saved)
function Adjustable.TabWindow:removeTab(which)
    assert(type(which) == "string" or type(which) == "number", "removeTab: bad argument #1 type (tab name/position as string or number expected, got "..type(which).."!)")
    if type(which) == "number" and which &lt;= #self.tabs then
        self[self.tabs[which].."tab"]:hide()
        self.header:remove(self[self.tabs[which].."tab"])
        self.header:organize()
        table.remove(self.tabs, which)
        return true
    end
    local index = table.index_of(self.tabs, which)
    if index then
        self[self.tabs[index].."tab"]:hide()
        self.header:remove(self[self.tabs[index].."tab"])
        self.header:organize()
        table.remove(self.tabs, index)
        return true
    end
    return nil, "removeTab: Couldn't find tab to remove"
end

-- adds a tab (this won't be saved)
function Adjustable.TabWindow:addTab(name, pos)
    assert(type(name) == "string", "addTab: bad argument #1 type (tab name as string expected, got "..type(name).."!)")
    pos = pos or #self.tabs
    pos = pos &gt; #self.tabs and #self.tabs or pos
    assert(type(pos) == "number", "addTab: bad argument #2 type (tab position as number expected, got "..type(pos).."!)")
    --check if tabName exists already
    local index = table.index_of(self.tabs, name)
    -- check if postion is valid
    if pos &lt; 1 and #self.tabs ~= 0 then
        return nil, "addTab: not a valid position"
    end
    
    pos = index and pos &gt; #self.tabs and #self.tabs or not(index) and pos == #self.tabs and pos + 1 or pos
    
    -- if tab exists and is at the same position already, do nothing
    if index == pos then
        self.header:organize()
        return true
    end
    
    -- if tab exists and position is different, then change the position
    if index then 
        table.remove(self.tabs, index)
        table.remove(self.header.windows, index)
    end
    table.insert(self.tabs, pos, name)
    
    -- if tab is new created a new Label
    if not index then
        self:createTabs()
        table.remove(self.header.windows, #self.header.windows)
    end
    
    table.insert(self.header.windows, pos, self[name.."tab"].name)
    self.header:organize()
    return true
end

--- saves your container settings
-- like tab position and some other variables in your Mudlet Profile Dir/ Adjustable.TabWindow
-- to be reliable it is important that every Adjustable.TabWindow has an unique 'name'
-- @see Adjustable.TabWindow:load
function Adjustable.TabWindow:save()
    local mytable = {}
    -- save fixed tabs
    for k,v in pairs(Adjustable.TabWindow.all) do
        mytable[k] = {}
        mytable[k].tabs = v.tabs
        mytable[k].current = v.current
    end
    -- save floating tabs and tabText
    for k,v in pairs(Adjustable.TabWindow.allTabs) do
        for k1,v1 in pairs(v) do
            if type(v1) == "table" and v1.floating then
                -- save the tabs adjustable container settings
                v[k1.."tab"]:save()
                -- get all floating tabs and their windownames
                mytable[v.name].floatingTabs = mytable[v.name].floatingTabs or {}
                mytable[v.name].floatingTabs[k1] = "main"
                if v1.windowname ~= "main" then
                    mytable[v.name].floatingTabs[k1] = v1.windowname
                end
            end
        end
    end
    if not(io.exists(getMudletHomeDir().."/AdjustableTabWindow/")) then lfs.mkdir(getMudletHomeDir().."/AdjustableTabWindow/") end
    table.save(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
end


--- restores/loads the before saved settings 
-- it is very important to load after all TabWindows are created
-- @see Adjustable.TabWindow:save
function Adjustable.TabWindow:load()
    local mytable = {}
    if io.exists(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua") then
        table.load(getMudletHomeDir().."/AdjustableTabWindow/TabWindowTabs.lua", mytable)
    end
    for k,v in pairs(mytable) do
        -- load fixed Tabs
        local myWindow = Adjustable.TabWindow.all[k]
        for k1,v1 in ipairs(v.tabs) do
            local myTabWindow = Adjustable.TabWindow.allTabs[v1]
            if myTabWindow then
                local myTab = myTabWindow[v1]
                if myTab.floating then
                    myTabWindow:restoreTab(v1)
                end
                if not myWindow.header.windowList[v1.."tab"] then
                    myTabWindow:changeTabContainer(v1, myWindow)
                end
                myWindow:addTab(v1,k1)
            end
        end
	if myWindow then
	    myWindow:deactivateTab()
	    myWindow.current = v.current
	    tempTimer(0, function() myWindow:activateTab(v.current) end)
	    myWindow:raiseAll() 
	end
        -- load floating Tabs
        if v.floatingTabs then
            for k1, v1 in pairs(v.floatingTabs) do
                local myTabWindow = Adjustable.TabWindow.allTabs[k1]
                if myTabWindow then
                    local myTab = myTabWindow[k1.."tab"]
                    myTabWindow:transformTabContainer(k1)
                    -- send my Tab to a UserWindow if saved there
                    if v1 ~= "main" then
                        myTab:changeContainer(Geyser.windowList[v1.."Container"].windowList[v1])
                    end
                    -- load Adjustable Container settings
                    myTab:load()
                end
            end
        end        
    end
end

function Adjustable.TabWindow:transferEMCO(emco)
  emco:hide()
  local emco_tabs = emco.tabs
  local emco_tabwindows = table.keys(emco.mc)
  local emco_windows = emco.mc
  
  -- xEcho override
  local myXEcho = 
  function(s, tabName, message, xtype, excludeAll)
    s.currentTab = self.current        
    if s.blink and tabName ~= s.currentTab then
      if not (s.allTabName == s.currentTab and not s.blinkFromAll) then
        s.tabsToBlink[tabName] = true
      end
    end   
    EMCO.xEcho(s, tabName, message, xtype, excludeAll)
   end
  
  -- Flash override
  local myFlash = 
  function(s)
    Geyser.Container.flash(s) 
    raiseWindow(s.name .."_dimensions_flash")
  end
  -- doBlink override
  local myDoBlink =
  function(s)
    s.currentTab = self.current
    if s.blink then
      if s.allTab and (s.currentTab == s.allTabName or self[s.allTabName].hidden == false) then
        s.tabsToBlink = {}
      elseif s.tabsToBlink[s.currentTab] then
        s.tabsToBlink[s.currentTab] = nil
      end
    end    
    for tab,_ in pairs(s.tabsToBlink) do
      if not self[tab].floating and self[tab].hidden then
        s.tabs[tab]:flash()
      else
        s.tabsToBlink[tab] = nil
      end
    end
  end
  
  --transfering process
  self.tabs = table.n_union(self.tabs, emco_tabwindows)
  self:createTabs()
  for k,v in ipairs(emco_tabwindows) do
    emco_windows[v]:show()
    emco_windows[v]:changeContainer(self[v.."center"])
    emco_tabs[v]:changeContainer(self[v.."tab"])
    emco_tabs[v]:move(0,0)
    emco_tabs[v]:resize("100%","100%")
    emco_tabs[v]:hide()
    emco_tabs[v].flash = myFlash
    if emco_tabs[v].font then
      self[v.."tab"].adjLabel:setFont(emco_tabs[v].font)
    end
  end
  emco.xEcho = myXEcho
  emco.doBlink = myDoBlink
end


-- Save a reference to our parent constructor
Adjustable.TabWindow.parent = Geyser.Container
-- Create table to put every Adjustable.TabWindow in it
Adjustable.TabWindow.all = Adjustable.TabWindow.all or {}
Adjustable.TabWindow.all_windows = Adjustable.TabWindow.all_windows or {}
Adjustable.TabWindow.allTabs = Adjustable.TabWindow.allTabs or {}

-- tabwindow constructor
function Adjustable.TabWindow:new(cons, container)
    Geyser.HBox.organize = Geyser.HBox.organize or Geyser.HBox.reposition
    local me = self.parent:new(cons, container)
    cons = cons or {}
    setmetatable(me, self)
    self.__index = self
    me.type = "adjustabletabwindow"
    me.tabs = me.tabs or {}
    me.tabTxtColor = me.tabTxtColor or "white"
    me.tabPadding = me.tabPadding or 12
    me.color1 = me.color1 or "rgb(0,0,100)"
    me.color2 = me.color2 or "rgb(0,0,70)"
    me.tabBarHeight = me.tabBarHeight or "10%"
    me.footerStyle = me.footerStyle or [[
    background-color: ]]..me.color1..[[;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
    ]]
    
    me.centerStyle = me.centerStyle or [[
    background-color: ]]..me.color2..[[;
    border-radius: 10px;
    margin: 5px;
    ]]
    
    me.inactiveTabStyle = me.inactiveTabStyle or [[QLabel::hover{
        background-color: ]]..me.color1..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    QLabel::!hover{
        background-color: ]]..me.color2..[[;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignTop';
    }
    ]]
    
    me.activeTabStyle = me.activeTabStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.chosenTabStyle = me.chosenTabStyle or [[
    background-color: rgba(255,30,0,60%);
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    qproperty-alignment: 'AlignTop';
    ]]
    
    me.containerStyle = me.containerStyle or [[
    background-color: ]]..me.color1..[[;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    margin-right: 1px;
    margin-left: 1px;
    ]]
    
    me.overlayStyle = me.overlayStyle or [[
    background-color: rgba(0,0,0,0%);
    border: 2px solid white;]]
    
    me.tabBarStyle = me.tabBarStyle or [[
    background-color: rgba(0,0,0,0%);
    ]]
    
    me:createBaseContainers()
    me:createTabs()
    me.current = me.current or me.tabs[#me.tabs]
    
    if me.tabs[1] then
        me:activateTab(me.tabs[1])
    end
    tempTimer(0, 
    function() 
      if me.tabs[1] then 
        me[me.tabs[#me.tabs]]:hide()
      end 
    end )
    
    if not Adjustable.TabWindow.all[me.name] then
        Adjustable.TabWindow.all_windows[#Adjustable.Container.all_windows + 1] = me.name
    end
    Adjustable.TabWindow.all[me.name] = me
    
    return me
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
